{"version":3,"file":"16.js","sources":["webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+client@1.10.0/node_modules/@orpc/client/dist/shared/client.DLfp86aF.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+shared@1.10.0/node_modules/@orpc/shared/dist/index.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+standard-server@1.10.0/node_modules/@orpc/standard-server/dist/index.mjs"],"sourcesContent":["import { resolveMaybeOptionalOptions, getConstructor, isObject, AsyncIteratorClass, isTypescriptObject } from '@orpc/shared';\nimport { getEventMeta, withEventMeta } from '@orpc/standard-server';\n\nconst ORPC_CLIENT_PACKAGE_NAME = \"@orpc/client\";\nconst ORPC_CLIENT_PACKAGE_VERSION = \"1.10.0\";\n\nconst COMMON_ORPC_ERROR_DEFS = {\n  BAD_REQUEST: {\n    status: 400,\n    message: \"Bad Request\"\n  },\n  UNAUTHORIZED: {\n    status: 401,\n    message: \"Unauthorized\"\n  },\n  FORBIDDEN: {\n    status: 403,\n    message: \"Forbidden\"\n  },\n  NOT_FOUND: {\n    status: 404,\n    message: \"Not Found\"\n  },\n  METHOD_NOT_SUPPORTED: {\n    status: 405,\n    message: \"Method Not Supported\"\n  },\n  NOT_ACCEPTABLE: {\n    status: 406,\n    message: \"Not Acceptable\"\n  },\n  TIMEOUT: {\n    status: 408,\n    message: \"Request Timeout\"\n  },\n  CONFLICT: {\n    status: 409,\n    message: \"Conflict\"\n  },\n  PRECONDITION_FAILED: {\n    status: 412,\n    message: \"Precondition Failed\"\n  },\n  PAYLOAD_TOO_LARGE: {\n    status: 413,\n    message: \"Payload Too Large\"\n  },\n  UNSUPPORTED_MEDIA_TYPE: {\n    status: 415,\n    message: \"Unsupported Media Type\"\n  },\n  UNPROCESSABLE_CONTENT: {\n    status: 422,\n    message: \"Unprocessable Content\"\n  },\n  TOO_MANY_REQUESTS: {\n    status: 429,\n    message: \"Too Many Requests\"\n  },\n  CLIENT_CLOSED_REQUEST: {\n    status: 499,\n    message: \"Client Closed Request\"\n  },\n  INTERNAL_SERVER_ERROR: {\n    status: 500,\n    message: \"Internal Server Error\"\n  },\n  NOT_IMPLEMENTED: {\n    status: 501,\n    message: \"Not Implemented\"\n  },\n  BAD_GATEWAY: {\n    status: 502,\n    message: \"Bad Gateway\"\n  },\n  SERVICE_UNAVAILABLE: {\n    status: 503,\n    message: \"Service Unavailable\"\n  },\n  GATEWAY_TIMEOUT: {\n    status: 504,\n    message: \"Gateway Timeout\"\n  }\n};\nfunction fallbackORPCErrorStatus(code, status) {\n  return status ?? COMMON_ORPC_ERROR_DEFS[code]?.status ?? 500;\n}\nfunction fallbackORPCErrorMessage(code, message) {\n  return message || COMMON_ORPC_ERROR_DEFS[code]?.message || code;\n}\nconst GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL = Symbol.for(`__${ORPC_CLIENT_PACKAGE_NAME}@${ORPC_CLIENT_PACKAGE_VERSION}/error/ORPC_ERROR_CONSTRUCTORS__`);\nvoid (globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL] ??= /* @__PURE__ */ new WeakSet());\nconst globalORPCErrorConstructors = globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL];\nclass ORPCError extends Error {\n  defined;\n  code;\n  status;\n  data;\n  constructor(code, ...rest) {\n    const options = resolveMaybeOptionalOptions(rest);\n    if (options.status !== void 0 && !isORPCErrorStatus(options.status)) {\n      throw new Error(\"[ORPCError] Invalid error status code.\");\n    }\n    const message = fallbackORPCErrorMessage(code, options.message);\n    super(message, options);\n    this.code = code;\n    this.status = fallbackORPCErrorStatus(code, options.status);\n    this.defined = options.defined ?? false;\n    this.data = options.data;\n  }\n  toJSON() {\n    return {\n      defined: this.defined,\n      code: this.code,\n      status: this.status,\n      message: this.message,\n      data: this.data\n    };\n  }\n  /**\n   * Workaround for Next.js where different contexts use separate\n   * dependency graphs, causing multiple ORPCError constructors existing and breaking\n   * `instanceof` checks across contexts.\n   *\n   * This is particularly problematic with \"Optimized SSR\", where orpc-client\n   * executes in one context but is invoked from another. When an error is thrown\n   * in the execution context, `instanceof ORPCError` checks fail in the\n   * invocation context due to separate class constructors.\n   *\n   * @todo Remove this and related code if Next.js resolves the multiple dependency graph issue.\n   */\n  static [Symbol.hasInstance](instance) {\n    if (globalORPCErrorConstructors.has(this)) {\n      const constructor = getConstructor(instance);\n      if (constructor && globalORPCErrorConstructors.has(constructor)) {\n        return true;\n      }\n    }\n    return super[Symbol.hasInstance](instance);\n  }\n}\nglobalORPCErrorConstructors.add(ORPCError);\nfunction isDefinedError(error) {\n  return error instanceof ORPCError && error.defined;\n}\nfunction toORPCError(error) {\n  return error instanceof ORPCError ? error : new ORPCError(\"INTERNAL_SERVER_ERROR\", {\n    message: \"Internal server error\",\n    cause: error\n  });\n}\nfunction isORPCErrorStatus(status) {\n  return status < 200 || status >= 400;\n}\nfunction isORPCErrorJson(json) {\n  if (!isObject(json)) {\n    return false;\n  }\n  const validKeys = [\"defined\", \"code\", \"status\", \"message\", \"data\"];\n  if (Object.keys(json).some((k) => !validKeys.includes(k))) {\n    return false;\n  }\n  return \"defined\" in json && typeof json.defined === \"boolean\" && \"code\" in json && typeof json.code === \"string\" && \"status\" in json && typeof json.status === \"number\" && isORPCErrorStatus(json.status) && \"message\" in json && typeof json.message === \"string\";\n}\nfunction createORPCErrorFromJson(json, options = {}) {\n  return new ORPCError(json.code, {\n    ...options,\n    ...json\n  });\n}\n\nfunction mapEventIterator(iterator, maps) {\n  const mapError = async (error) => {\n    let mappedError = await maps.error(error);\n    if (mappedError !== error) {\n      const meta = getEventMeta(error);\n      if (meta && isTypescriptObject(mappedError)) {\n        mappedError = withEventMeta(mappedError, meta);\n      }\n    }\n    return mappedError;\n  };\n  return new AsyncIteratorClass(async () => {\n    const { done, value } = await (async () => {\n      try {\n        return await iterator.next();\n      } catch (error) {\n        throw await mapError(error);\n      }\n    })();\n    let mappedValue = await maps.value(value, done);\n    if (mappedValue !== value) {\n      const meta = getEventMeta(value);\n      if (meta && isTypescriptObject(mappedValue)) {\n        mappedValue = withEventMeta(mappedValue, meta);\n      }\n    }\n    return { done, value: mappedValue };\n  }, async () => {\n    try {\n      await iterator.return?.();\n    } catch (error) {\n      throw await mapError(error);\n    }\n  });\n}\n\nexport { COMMON_ORPC_ERROR_DEFS as C, ORPC_CLIENT_PACKAGE_NAME as O, ORPC_CLIENT_PACKAGE_VERSION as a, fallbackORPCErrorMessage as b, ORPCError as c, isORPCErrorStatus as d, isORPCErrorJson as e, fallbackORPCErrorStatus as f, createORPCErrorFromJson as g, isDefinedError as i, mapEventIterator as m, toORPCError as t };\n","export { group, guard, mapEntries, mapValues, omit, retry, sleep } from 'radash';\n\nfunction resolveMaybeOptionalOptions(rest) {\n  return rest[0] ?? {};\n}\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];\n}\nfunction splitInHalf(arr) {\n  const half = Math.ceil(arr.length / 2);\n  return [arr.slice(0, half), arr.slice(half)];\n}\n\nfunction readAsBuffer(source) {\n  if (typeof source.bytes === \"function\") {\n    return source.bytes();\n  }\n  return source.arrayBuffer();\n}\n\nconst ORPC_NAME = \"orpc\";\nconst ORPC_SHARED_PACKAGE_NAME = \"@orpc/shared\";\nconst ORPC_SHARED_PACKAGE_VERSION = \"1.10.0\";\n\nclass AbortError extends Error {\n  constructor(...rest) {\n    super(...rest);\n    this.name = \"AbortError\";\n  }\n}\n\nfunction once(fn) {\n  let cached;\n  return () => {\n    if (cached) {\n      return cached.result;\n    }\n    const result = fn();\n    cached = { result };\n    return result;\n  };\n}\nfunction sequential(fn) {\n  let lastOperationPromise = Promise.resolve();\n  return (...args) => {\n    return lastOperationPromise = lastOperationPromise.catch(() => {\n    }).then(() => {\n      return fn(...args);\n    });\n  };\n}\nfunction defer(callback) {\n  if (typeof setTimeout === \"function\") {\n    setTimeout(callback, 0);\n  } else {\n    Promise.resolve().then(() => Promise.resolve().then(() => Promise.resolve().then(callback)));\n  }\n}\n\nconst SPAN_ERROR_STATUS = 2;\nconst GLOBAL_OTEL_CONFIG_KEY = `__${ORPC_SHARED_PACKAGE_NAME}@${ORPC_SHARED_PACKAGE_VERSION}/otel/config__`;\nfunction setGlobalOtelConfig(config) {\n  globalThis[GLOBAL_OTEL_CONFIG_KEY] = config;\n}\nfunction getGlobalOtelConfig() {\n  return globalThis[GLOBAL_OTEL_CONFIG_KEY];\n}\nfunction startSpan(name, options = {}, context) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  return tracer?.startSpan(name, options, context);\n}\nfunction setSpanError(span, error, options = {}) {\n  if (!span) {\n    return;\n  }\n  const exception = toOtelException(error);\n  span.recordException(exception);\n  if (!options.signal?.aborted || options.signal.reason !== error) {\n    span.setStatus({\n      code: SPAN_ERROR_STATUS,\n      message: exception.message\n    });\n  }\n}\nfunction setSpanAttribute(span, key, value) {\n  if (!span || value === void 0) {\n    return;\n  }\n  span.setAttribute(key, value);\n}\nfunction toOtelException(error) {\n  if (error instanceof Error) {\n    const exception = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack\n    };\n    if (\"code\" in error && (typeof error.code === \"string\" || typeof error.code === \"number\")) {\n      exception.code = error.code;\n    }\n    return exception;\n  }\n  return { message: String(error) };\n}\nfunction toSpanAttributeValue(data) {\n  if (data === void 0) {\n    return \"undefined\";\n  }\n  try {\n    return JSON.stringify(data, (_, value) => {\n      if (typeof value === \"bigint\") {\n        return value.toString();\n      }\n      if (value instanceof Map || value instanceof Set) {\n        return Array.from(value);\n      }\n      return value;\n    });\n  } catch {\n    return String(data);\n  }\n}\nasync function runWithSpan({ name, context, ...options }, fn) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  if (!tracer) {\n    return fn();\n  }\n  const callback = async (span) => {\n    try {\n      return await fn(span);\n    } catch (e) {\n      setSpanError(span, e, options);\n      throw e;\n    } finally {\n      span.end();\n    }\n  };\n  if (context) {\n    return tracer.startActiveSpan(name, options, context, callback);\n  } else {\n    return tracer.startActiveSpan(name, options, callback);\n  }\n}\nasync function runInSpanContext(span, fn) {\n  const otelConfig = getGlobalOtelConfig();\n  if (!span || !otelConfig) {\n    return fn();\n  }\n  const ctx = otelConfig.trace.setSpan(otelConfig.context.active(), span);\n  return otelConfig.context.with(ctx, fn);\n}\n\nclass AsyncIdQueue {\n  openIds = /* @__PURE__ */ new Set();\n  queues = /* @__PURE__ */ new Map();\n  waiters = /* @__PURE__ */ new Map();\n  get length() {\n    return this.openIds.size;\n  }\n  get waiterIds() {\n    return Array.from(this.waiters.keys());\n  }\n  hasBufferedItems(id) {\n    return Boolean(this.queues.get(id)?.length);\n  }\n  open(id) {\n    this.openIds.add(id);\n  }\n  isOpen(id) {\n    return this.openIds.has(id);\n  }\n  push(id, item) {\n    this.assertOpen(id);\n    const pending = this.waiters.get(id);\n    if (pending?.length) {\n      pending.shift()[0](item);\n      if (pending.length === 0) {\n        this.waiters.delete(id);\n      }\n    } else {\n      const items = this.queues.get(id);\n      if (items) {\n        items.push(item);\n      } else {\n        this.queues.set(id, [item]);\n      }\n    }\n  }\n  async pull(id) {\n    this.assertOpen(id);\n    const items = this.queues.get(id);\n    if (items?.length) {\n      const item = items.shift();\n      if (items.length === 0) {\n        this.queues.delete(id);\n      }\n      return item;\n    }\n    return new Promise((resolve, reject) => {\n      const waitingPulls = this.waiters.get(id);\n      const pending = [resolve, reject];\n      if (waitingPulls) {\n        waitingPulls.push(pending);\n      } else {\n        this.waiters.set(id, [pending]);\n      }\n    });\n  }\n  close({ id, reason } = {}) {\n    if (id === void 0) {\n      this.waiters.forEach((pendingPulls, id2) => {\n        const error2 = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id2}] was closed or aborted while waiting for pulling.`);\n        pendingPulls.forEach(([, reject]) => reject(error2));\n      });\n      this.waiters.clear();\n      this.openIds.clear();\n      this.queues.clear();\n      return;\n    }\n    const error = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id}] was closed or aborted while waiting for pulling.`);\n    this.waiters.get(id)?.forEach(([, reject]) => reject(error));\n    this.waiters.delete(id);\n    this.openIds.delete(id);\n    this.queues.delete(id);\n  }\n  assertOpen(id) {\n    if (!this.isOpen(id)) {\n      throw new Error(`[AsyncIdQueue] Cannot access queue[${id}] because it is not open or aborted.`);\n    }\n  }\n}\n\nfunction isAsyncIteratorObject(maybe) {\n  if (!maybe || typeof maybe !== \"object\") {\n    return false;\n  }\n  return \"next\" in maybe && typeof maybe.next === \"function\" && Symbol.asyncIterator in maybe && typeof maybe[Symbol.asyncIterator] === \"function\";\n}\nconst fallbackAsyncDisposeSymbol = Symbol.for(\"asyncDispose\");\nconst asyncDisposeSymbol = Symbol.asyncDispose ?? fallbackAsyncDisposeSymbol;\nclass AsyncIteratorClass {\n  #isDone = false;\n  #isExecuteComplete = false;\n  #cleanup;\n  #next;\n  constructor(next, cleanup) {\n    this.#cleanup = cleanup;\n    this.#next = sequential(async () => {\n      if (this.#isDone) {\n        return { done: true, value: void 0 };\n      }\n      try {\n        const result = await next();\n        if (result.done) {\n          this.#isDone = true;\n        }\n        return result;\n      } catch (err) {\n        this.#isDone = true;\n        throw err;\n      } finally {\n        if (this.#isDone && !this.#isExecuteComplete) {\n          this.#isExecuteComplete = true;\n          await this.#cleanup(\"next\");\n        }\n      }\n    });\n  }\n  next() {\n    return this.#next();\n  }\n  async return(value) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"return\");\n    }\n    return { done: true, value };\n  }\n  async throw(err) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"throw\");\n    }\n    throw err;\n  }\n  /**\n   * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')\n   */\n  async [asyncDisposeSymbol]() {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"dispose\");\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\nfunction replicateAsyncIterator(source, count) {\n  const queue = new AsyncIdQueue();\n  const ids = Array.from({ length: count }, (_, i) => i.toString());\n  let isSourceFinished = false;\n  const start = once(async () => {\n    try {\n      while (true) {\n        const item = await source.next();\n        ids.forEach((id) => {\n          if (queue.isOpen(id)) {\n            queue.push(id, { next: item });\n          }\n        });\n        if (item.done) {\n          break;\n        }\n      }\n    } catch (error) {\n      ids.forEach((id) => {\n        if (queue.isOpen(id)) {\n          queue.push(id, { error });\n        }\n      });\n    } finally {\n      isSourceFinished = true;\n    }\n  });\n  const replicated = ids.map((id) => {\n    queue.open(id);\n    return new AsyncIteratorClass(\n      async () => {\n        start();\n        const item = await queue.pull(id);\n        if (item.next) {\n          return item.next;\n        }\n        throw item.error;\n      },\n      async (reason) => {\n        queue.close({ id });\n        if (reason !== \"next\" && !queue.length && !isSourceFinished) {\n          isSourceFinished = true;\n          await source?.return?.();\n        }\n      }\n    );\n  });\n  return replicated;\n}\nfunction asyncIteratorWithSpan({ name, ...options }, iterator) {\n  let span;\n  return new AsyncIteratorClass(\n    async () => {\n      span ??= startSpan(name);\n      try {\n        const result = await runInSpanContext(span, () => iterator.next());\n        span?.addEvent(result.done ? \"completed\" : \"yielded\");\n        return result;\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      }\n    },\n    async (reason) => {\n      try {\n        if (reason !== \"next\") {\n          await runInSpanContext(span, () => iterator.return?.());\n        }\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      } finally {\n        span?.end();\n      }\n    }\n  );\n}\n\nclass EventPublisher {\n  #listenersMap = /* @__PURE__ */ new Map();\n  #maxBufferedEvents;\n  constructor(options = {}) {\n    this.#maxBufferedEvents = options.maxBufferedEvents ?? 100;\n  }\n  get size() {\n    return this.#listenersMap.size;\n  }\n  /**\n   * Emits an event and delivers the payload to all subscribed listeners.\n   */\n  publish(event, payload) {\n    const listeners = this.#listenersMap.get(event);\n    if (!listeners) {\n      return;\n    }\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n  subscribe(event, listenerOrOptions) {\n    if (typeof listenerOrOptions === \"function\") {\n      let listeners = this.#listenersMap.get(event);\n      if (!listeners) {\n        this.#listenersMap.set(event, listeners = []);\n      }\n      listeners.push(listenerOrOptions);\n      return once(() => {\n        listeners.splice(listeners.indexOf(listenerOrOptions), 1);\n        if (listeners.length === 0) {\n          this.#listenersMap.delete(event);\n        }\n      });\n    }\n    const signal = listenerOrOptions?.signal;\n    const maxBufferedEvents = listenerOrOptions?.maxBufferedEvents ?? this.#maxBufferedEvents;\n    signal?.throwIfAborted();\n    const bufferedEvents = [];\n    const pullResolvers = [];\n    const unsubscribe = this.subscribe(event, (payload) => {\n      const resolver = pullResolvers.shift();\n      if (resolver) {\n        resolver[0]({ done: false, value: payload });\n      } else {\n        bufferedEvents.push(payload);\n        if (bufferedEvents.length > maxBufferedEvents) {\n          bufferedEvents.shift();\n        }\n      }\n    });\n    const abortListener = (event2) => {\n      unsubscribe();\n      pullResolvers.forEach((resolver) => resolver[1](event2.target.reason));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    };\n    signal?.addEventListener(\"abort\", abortListener, { once: true });\n    return new AsyncIteratorClass(async () => {\n      if (signal?.aborted) {\n        throw signal.reason;\n      }\n      if (bufferedEvents.length > 0) {\n        return { done: false, value: bufferedEvents.shift() };\n      }\n      return new Promise((resolve, reject) => {\n        pullResolvers.push([resolve, reject]);\n      });\n    }, async () => {\n      unsubscribe();\n      signal?.removeEventListener(\"abort\", abortListener);\n      pullResolvers.forEach((resolver) => resolver[0]({ done: true, value: void 0 }));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    });\n  }\n}\n\nclass SequentialIdGenerator {\n  index = BigInt(1);\n  generate() {\n    const id = this.index.toString(36);\n    this.index++;\n    return id;\n  }\n}\nfunction compareSequentialIds(a, b) {\n  if (a.length !== b.length) {\n    return a.length - b.length;\n  }\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction onStart(callback) {\n  return async (options, ...rest) => {\n    await callback(options, ...rest);\n    return await options.next();\n  };\n}\nfunction onSuccess(callback) {\n  return async (options, ...rest) => {\n    const result = await options.next();\n    await callback(result, options, ...rest);\n    return result;\n  };\n}\nfunction onError(callback) {\n  return async (options, ...rest) => {\n    try {\n      return await options.next();\n    } catch (error) {\n      await callback(error, options, ...rest);\n      throw error;\n    }\n  };\n}\nfunction onFinish(callback) {\n  let state;\n  return async (options, ...rest) => {\n    try {\n      const result = await options.next();\n      state = [null, result, true];\n      return result;\n    } catch (error) {\n      state = [error, void 0, false];\n      throw error;\n    } finally {\n      await callback(state, options, ...rest);\n    }\n  };\n}\nfunction intercept(interceptors, options, main) {\n  const next = (options2, index) => {\n    const interceptor = interceptors[index];\n    if (!interceptor) {\n      return main(options2);\n    }\n    return interceptor({\n      ...options2,\n      next: (newOptions = options2) => next(newOptions, index + 1)\n    });\n  };\n  return next(options, 0);\n}\n\nfunction parseEmptyableJSON(text) {\n  if (!text) {\n    return void 0;\n  }\n  return JSON.parse(text);\n}\nfunction stringifyJSON(value) {\n  return JSON.stringify(value);\n}\n\nfunction findDeepMatches(check, payload, segments = [], maps = [], values = []) {\n  if (check(payload)) {\n    maps.push(segments);\n    values.push(payload);\n  } else if (Array.isArray(payload)) {\n    payload.forEach((v, i) => {\n      findDeepMatches(check, v, [...segments, i], maps, values);\n    });\n  } else if (isObject(payload)) {\n    for (const key in payload) {\n      findDeepMatches(check, payload[key], [...segments, key], maps, values);\n    }\n  }\n  return { maps, values };\n}\nfunction getConstructor(value) {\n  if (!isTypescriptObject(value)) {\n    return null;\n  }\n  return Object.getPrototypeOf(value)?.constructor;\n}\nfunction isObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || !proto || !proto.constructor;\n}\nfunction isTypescriptObject(value) {\n  return !!value && (typeof value === \"object\" || typeof value === \"function\");\n}\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  }\n  if (isObject(value)) {\n    const result = {};\n    for (const key in value) {\n      result[key] = clone(value[key]);\n    }\n    return result;\n  }\n  return value;\n}\nfunction get(object, path) {\n  let current = object;\n  for (const key of path) {\n    if (!isTypescriptObject(current)) {\n      return void 0;\n    }\n    current = current[key];\n  }\n  return current;\n}\nfunction isPropertyKey(value) {\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"symbol\";\n}\nconst NullProtoObj = /* @__PURE__ */ (() => {\n  const e = function() {\n  };\n  e.prototype = /* @__PURE__ */ Object.create(null);\n  Object.freeze(e.prototype);\n  return e;\n})();\n\nfunction value(value2, ...args) {\n  if (typeof value2 === \"function\") {\n    return value2(...args);\n  }\n  return value2;\n}\nfunction fallback(value2, fallback2) {\n  return value2 === void 0 ? fallback2 : value2;\n}\n\nfunction preventNativeAwait(target) {\n  return new Proxy(target, {\n    get(target2, prop, receiver) {\n      const value2 = Reflect.get(target2, prop, receiver);\n      if (prop !== \"then\" || typeof value2 !== \"function\") {\n        return value2;\n      }\n      return new Proxy(value2, {\n        apply(targetFn, thisArg, args) {\n          if (args.length !== 2 || args.some((arg) => !isNativeFunction(arg))) {\n            return Reflect.apply(targetFn, thisArg, args);\n          }\n          let shouldOmit = true;\n          args[0].call(thisArg, preventNativeAwait(new Proxy(target2, {\n            get: (target3, prop2, receiver2) => {\n              if (shouldOmit && prop2 === \"then\") {\n                shouldOmit = false;\n                return void 0;\n              }\n              return Reflect.get(target3, prop2, receiver2);\n            }\n          })));\n        }\n      });\n    }\n  });\n}\nconst NATIVE_FUNCTION_REGEX = /^\\s*function\\s*\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*$/;\nfunction isNativeFunction(fn) {\n  return typeof fn === \"function\" && NATIVE_FUNCTION_REGEX.test(fn.toString());\n}\nfunction overlayProxy(target, partial) {\n  const proxy = new Proxy(typeof target === \"function\" ? partial : target, {\n    get(_, prop) {\n      const targetValue = prop in partial ? partial : value(target);\n      const v = Reflect.get(targetValue, prop);\n      return typeof v === \"function\" ? v.bind(targetValue) : v;\n    },\n    has(_, prop) {\n      return Reflect.has(partial, prop) || Reflect.has(value(target), prop);\n    }\n  });\n  return proxy;\n}\n\nfunction streamToAsyncIteratorClass(stream) {\n  const reader = stream.getReader();\n  return new AsyncIteratorClass(\n    async () => {\n      return reader.read();\n    },\n    async () => {\n      await reader.cancel();\n    }\n  );\n}\nfunction asyncIteratorToStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\nfunction asyncIteratorToUnproxiedDataStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        const unproxied = isObject(value) ? { ...value } : Array.isArray(value) ? value.map((i) => i) : value;\n        controller.enqueue(unproxied);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\n\nfunction tryDecodeURIComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch {\n    return value;\n  }\n}\n\nexport { AbortError, AsyncIdQueue, AsyncIteratorClass, EventPublisher, NullProtoObj, ORPC_NAME, ORPC_SHARED_PACKAGE_NAME, ORPC_SHARED_PACKAGE_VERSION, SequentialIdGenerator, asyncIteratorToStream, asyncIteratorToUnproxiedDataStream, asyncIteratorWithSpan, clone, compareSequentialIds, defer, fallback, findDeepMatches, get, getConstructor, getGlobalOtelConfig, intercept, isAsyncIteratorObject, isObject, isPropertyKey, isTypescriptObject, onError, onFinish, onStart, onSuccess, once, overlayProxy, parseEmptyableJSON, preventNativeAwait, readAsBuffer, replicateAsyncIterator, resolveMaybeOptionalOptions, runInSpanContext, runWithSpan, sequential, setGlobalOtelConfig, setSpanAttribute, setSpanError, splitInHalf, startSpan, streamToAsyncIteratorClass, stringifyJSON, toArray, toOtelException, toSpanAttributeValue, tryDecodeURIComponent, value };\n","import { isTypescriptObject, AsyncIteratorClass, tryDecodeURIComponent, toArray, once, isAsyncIteratorObject, replicateAsyncIterator } from '@orpc/shared';\n\nclass EventEncoderError extends TypeError {\n}\nclass EventDecoderError extends TypeError {\n}\nclass ErrorEvent extends Error {\n  data;\n  constructor(options) {\n    super(options?.message ?? \"An error event was received\", options);\n    this.data = options?.data;\n  }\n}\n\nfunction decodeEventMessage(encoded) {\n  const lines = encoded.replace(/\\n+$/, \"\").split(/\\n/);\n  const message = {\n    data: void 0,\n    event: void 0,\n    id: void 0,\n    retry: void 0,\n    comments: []\n  };\n  for (const line of lines) {\n    const index = line.indexOf(\":\");\n    const key = index === -1 ? line : line.slice(0, index);\n    const value = index === -1 ? \"\" : line.slice(index + 1).replace(/^\\s/, \"\");\n    if (index === 0) {\n      message.comments.push(value);\n    } else if (key === \"data\") {\n      message.data ??= \"\";\n      message.data += `${value}\n`;\n    } else if (key === \"event\") {\n      message.event = value;\n    } else if (key === \"id\") {\n      message.id = value;\n    } else if (key === \"retry\") {\n      const maybeInteger = Number.parseInt(value);\n      if (Number.isInteger(maybeInteger) && maybeInteger >= 0 && maybeInteger.toString() === value) {\n        message.retry = maybeInteger;\n      }\n    }\n  }\n  message.data = message.data?.replace(/\\n$/, \"\");\n  return message;\n}\nclass EventDecoder {\n  constructor(options = {}) {\n    this.options = options;\n  }\n  incomplete = \"\";\n  feed(chunk) {\n    this.incomplete += chunk;\n    const lastCompleteIndex = this.incomplete.lastIndexOf(\"\\n\\n\");\n    if (lastCompleteIndex === -1) {\n      return;\n    }\n    const completes = this.incomplete.slice(0, lastCompleteIndex).split(/\\n\\n/);\n    this.incomplete = this.incomplete.slice(lastCompleteIndex + 2);\n    for (const encoded of completes) {\n      const message = decodeEventMessage(`${encoded}\n\n`);\n      if (this.options.onEvent) {\n        this.options.onEvent(message);\n      }\n    }\n    this.incomplete = \"\";\n  }\n  end() {\n    if (this.incomplete) {\n      throw new EventDecoderError(\"Event Iterator ended before complete\");\n    }\n  }\n}\nclass EventDecoderStream extends TransformStream {\n  constructor() {\n    let decoder;\n    super({\n      start(controller) {\n        decoder = new EventDecoder({\n          onEvent: (event) => {\n            controller.enqueue(event);\n          }\n        });\n      },\n      transform(chunk) {\n        decoder.feed(chunk);\n      },\n      flush() {\n        decoder.end();\n      }\n    });\n  }\n}\n\nfunction assertEventId(id) {\n  if (id.includes(\"\\n\")) {\n    throw new EventEncoderError(\"Event's id must not contain a newline character\");\n  }\n}\nfunction assertEventName(event) {\n  if (event.includes(\"\\n\")) {\n    throw new EventEncoderError(\"Event's event must not contain a newline character\");\n  }\n}\nfunction assertEventRetry(retry) {\n  if (!Number.isInteger(retry) || retry < 0) {\n    throw new EventEncoderError(\"Event's retry must be a integer and >= 0\");\n  }\n}\nfunction assertEventComment(comment) {\n  if (comment.includes(\"\\n\")) {\n    throw new EventEncoderError(\"Event's comment must not contain a newline character\");\n  }\n}\nfunction encodeEventData(data) {\n  const lines = data?.split(/\\n/) ?? [];\n  let output = \"\";\n  for (const line of lines) {\n    output += `data: ${line}\n`;\n  }\n  return output;\n}\nfunction encodeEventComments(comments) {\n  let output = \"\";\n  for (const comment of comments ?? []) {\n    assertEventComment(comment);\n    output += `: ${comment}\n`;\n  }\n  return output;\n}\nfunction encodeEventMessage(message) {\n  let output = \"\";\n  output += encodeEventComments(message.comments);\n  if (message.event !== void 0) {\n    assertEventName(message.event);\n    output += `event: ${message.event}\n`;\n  }\n  if (message.retry !== void 0) {\n    assertEventRetry(message.retry);\n    output += `retry: ${message.retry}\n`;\n  }\n  if (message.id !== void 0) {\n    assertEventId(message.id);\n    output += `id: ${message.id}\n`;\n  }\n  output += encodeEventData(message.data);\n  output += \"\\n\";\n  return output;\n}\n\nconst EVENT_SOURCE_META_SYMBOL = Symbol(\"ORPC_EVENT_SOURCE_META\");\nfunction withEventMeta(container, meta) {\n  if (meta.id === void 0 && meta.retry === void 0 && !meta.comments?.length) {\n    return container;\n  }\n  if (meta.id !== void 0) {\n    assertEventId(meta.id);\n  }\n  if (meta.retry !== void 0) {\n    assertEventRetry(meta.retry);\n  }\n  if (meta.comments !== void 0) {\n    for (const comment of meta.comments) {\n      assertEventComment(comment);\n    }\n  }\n  return new Proxy(container, {\n    get(target, prop, receiver) {\n      if (prop === EVENT_SOURCE_META_SYMBOL) {\n        return meta;\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction getEventMeta(container) {\n  return isTypescriptObject(container) ? Reflect.get(container, EVENT_SOURCE_META_SYMBOL) : void 0;\n}\n\nclass HibernationEventIterator extends AsyncIteratorClass {\n  /**\n   * this property is not transferred to the client, so it should be optional for type safety\n   */\n  hibernationCallback;\n  constructor(hibernationCallback) {\n    super(async () => {\n      throw new Error(\"Cannot iterate over hibernating iterator directly\");\n    }, async (reason) => {\n      if (reason !== \"next\") {\n        throw new Error(\"Cannot cleanup hibernating iterator directly\");\n      }\n    });\n    this.hibernationCallback = hibernationCallback;\n  }\n}\n\nfunction generateContentDisposition(filename) {\n  const escapedFileName = filename.replace(/\"/g, '\\\\\"');\n  const encodedFilenameStar = encodeURIComponent(filename).replace(/['()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`).replace(/%(7C|60|5E)/g, (str, hex) => String.fromCharCode(Number.parseInt(hex, 16)));\n  return `inline; filename=\"${escapedFileName}\"; filename*=utf-8''${encodedFilenameStar}`;\n}\nfunction getFilenameFromContentDisposition(contentDisposition) {\n  const encodedFilenameStarMatch = contentDisposition.match(/filename\\*=(UTF-8'')?([^;]*)/i);\n  if (encodedFilenameStarMatch && typeof encodedFilenameStarMatch[2] === \"string\") {\n    return tryDecodeURIComponent(encodedFilenameStarMatch[2]);\n  }\n  const encodedFilenameMatch = contentDisposition.match(/filename=\"((?:\\\\\"|[^\"])*)\"/i);\n  if (encodedFilenameMatch && typeof encodedFilenameMatch[1] === \"string\") {\n    return encodedFilenameMatch[1].replace(/\\\\\"/g, '\"');\n  }\n}\nfunction mergeStandardHeaders(a, b) {\n  const merged = { ...a };\n  for (const key in b) {\n    if (Array.isArray(b[key])) {\n      merged[key] = [...toArray(merged[key]), ...b[key]];\n    } else if (b[key] !== void 0) {\n      if (Array.isArray(merged[key])) {\n        merged[key] = [...merged[key], b[key]];\n      } else if (merged[key] !== void 0) {\n        merged[key] = [merged[key], b[key]];\n      } else {\n        merged[key] = b[key];\n      }\n    }\n  }\n  return merged;\n}\nfunction flattenHeader(header) {\n  if (typeof header === \"string\" || header === void 0) {\n    return header;\n  }\n  if (header.length === 0) {\n    return void 0;\n  }\n  return header.join(\", \");\n}\nfunction replicateStandardLazyResponse(response, count) {\n  const replicated = [];\n  let bodyPromise;\n  let replicatedAsyncIteratorObjects;\n  for (let i = 0; i < count; i++) {\n    replicated.push({\n      ...response,\n      body: once(async () => {\n        const body = await (bodyPromise ??= response.body());\n        if (!isAsyncIteratorObject(body)) {\n          return body;\n        }\n        replicatedAsyncIteratorObjects ??= replicateAsyncIterator(body, count);\n        return replicatedAsyncIteratorObjects.shift();\n      })\n    });\n  }\n  return replicated;\n}\nfunction isEventIteratorHeaders(headers) {\n  return Boolean(flattenHeader(headers[\"content-type\"])?.startsWith(\"text/event-stream\") && flattenHeader(headers[\"content-disposition\"]) === void 0);\n}\n\nexport { ErrorEvent, EventDecoder, EventDecoderError, EventDecoderStream, EventEncoderError, HibernationEventIterator, assertEventComment, assertEventId, assertEventName, assertEventRetry, decodeEventMessage, encodeEventComments, encodeEventData, encodeEventMessage, flattenHeader, generateContentDisposition, getEventMeta, getFilenameFromContentDisposition, isEventIteratorHeaders, mergeStandardHeaders, replicateStandardLazyResponse, withEventMeta };\n"],"names":["Symbol","globalThis","WeakSet","Error","r","e","Object","m","Array","String","Promise","Map","BigInt","JSON","t","Proxy","Reflect","ReadableStream","TypeError","TransformStream","Number"],"mappings":"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"}